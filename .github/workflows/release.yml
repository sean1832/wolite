name: Release

# Trigger the workflow when a release is created
on:
  release:
    types: [published]

# This ensures only one workflow runs at a time for the same release if triggered multiple times
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build-and-release:
    name: Build and Release
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to upload assets to the release
      packages: write # Needed if we push to GHCR (optional, currently using Docker Hub)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # --- 1. Efficient Frontend Build (Run Once) ---
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install Frontend Dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build Frontend
        working-directory: ./frontend
        run: npm run build

      # Copy frontend build to backend directory (embedded fs)
      # This mimics the 'task default' behavior but is platform-agnostic for CI
      - name: Prepare Backend Embed
        run: |
          mkdir -p backend/internal/ui/dist
          cp -r frontend/build/* backend/internal/ui/dist/

      # --- 2. Efficient Backend Build (Cross-Compile on Linux Runner) ---
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25" # Using latest stable Go version
          cache-dependency-path: backend/go.sum

      - name: Set TAG_NAME
        id: tag
        run: |
          TAG_NAME="${{ github.event.release.tag_name }}"
          if [ -z "$TAG_NAME" ]; then TAG_NAME="latest"; fi
          echo "TAG_NAME=${TAG_NAME}" >> "$GITHUB_OUTPUT"

      - name: Build and Package Binaries
        run: |
          mkdir -p artifacts bin

          TAG_NAME="${{ steps.tag.outputs.TAG_NAME }}"

          # Define platforms to build for
          # Format: GOOS/GOARCH
          platforms=(
            "linux/amd64"
            "linux/arm64"
            "windows/amd64"
            "darwin/amd64"
            "darwin/arm64"
          )

          for platform in "${platforms[@]}"; do
            GOOS=${platform%/*}
            GOARCH=${platform#*/}
            BINARY_NAME="wolite"
            # Format: wolite-<tag>-<os>-<arch>
            OUTPUT_NAME="wolite-${TAG_NAME}-${GOOS}-${GOARCH}"
            ARCHIVE_EXT=".tar.gz"
            
            # Windows specific handling
            if [ "$GOOS" = "windows" ]; then
              BINARY_NAME="${BINARY_NAME}.exe"
              ARCHIVE_EXT=".zip"
            fi
            
            echo "Building for $GOOS/$GOARCH..."
            
            # Build the binary
            # -s -w: Strip debug information for smaller binary
            # CGO_ENABLED=0: Static binary (no C dependency)
            export CGO_ENABLED=0
            export GOOS=$GOOS
            export GOARCH=$GOARCH
            
            cd backend && go build -ldflags="-s -w" -trimpath -o "../bin/${BINARY_NAME}" . && cd ..
            
            # Package the binary
            if [ "$GOOS" = "windows" ]; then
              zip -j "artifacts/${OUTPUT_NAME}${ARCHIVE_EXT}" "bin/${BINARY_NAME}"
            else
              tar -czf "artifacts/${OUTPUT_NAME}${ARCHIVE_EXT}" -C bin "${BINARY_NAME}"
            fi
            
            # Clean up bin directory for next iteration
            rm -rf bin/*
          done

          echo "Build complete. Artifacts:"
          ls -l artifacts/

      # --- 3. Build Companion App ---
      - name: Install Companion GUI Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc libgtk-3-dev libayatana-appindicator3-dev

      - name: Build and Package Companion
        run: |
          TAG_NAME="${{ steps.tag.outputs.TAG_NAME }}"

          # Define companion build targets
          # Format: BUILD_TAG/GOOS/GOARCH/CGO_ENABLED/EXTRA_LDFLAGS
          targets=(
            "gui/linux/amd64/1/"
            "gui/windows/amd64/0/-H=windowsgui"
            "cli/linux/amd64/0/"
            "cli/windows/amd64/0/"
          )

          for target in "${targets[@]}"; do
            IFS='/' read -r BUILD_TAG GOOS GOARCH CGO_ENABLED EXTRA_LDFLAGS <<< "$target"

            BINARY_NAME="wolite-companion"
            # Append build tag suffix for non-gui builds (cli -> wolite-companion-cli)
            if [ "$BUILD_TAG" != "gui" ]; then
              BINARY_NAME="${BINARY_NAME}-${BUILD_TAG}"
            fi

            # Format: wolite-companion[-variant]-<tag>-<os>-<arch>
            OUTPUT_NAME="${BINARY_NAME}-${TAG_NAME}-${GOOS}-${GOARCH}"
            ARCHIVE_EXT=".tar.gz"

            if [ "$GOOS" = "windows" ]; then
              BINARY_NAME="${BINARY_NAME}.exe"
              ARCHIVE_EXT=".zip"
            fi

            LDFLAGS="-s -w"
            if [ -n "$EXTRA_LDFLAGS" ]; then
              LDFLAGS="${EXTRA_LDFLAGS} ${LDFLAGS}"
            fi

            echo "Building Companion (${BUILD_TAG}) for ${GOOS}/${GOARCH}..."

            cd companion
            GOOS=$GOOS GOARCH=$GOARCH CGO_ENABLED=$CGO_ENABLED \
              go build -tags "$BUILD_TAG" -ldflags="$LDFLAGS" -o "../bin/${BINARY_NAME}" .
            cd ..

            # Package the binary
            if [ "$GOOS" = "windows" ]; then
              zip -j "artifacts/${OUTPUT_NAME}${ARCHIVE_EXT}" "bin/${BINARY_NAME}"
            else
              tar -czf "artifacts/${OUTPUT_NAME}${ARCHIVE_EXT}" -C bin "${BINARY_NAME}"
            fi

            rm -rf bin/*
          done

          echo "Companion build complete. Artifacts:"
          ls -l artifacts/

      # --- 4. Upload Binaries to GitHub Release ---
      - name: Upload Binaries to Release
        uses: softprops/action-gh-release@v2
        with:
          files: artifacts/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # --- 5. Docker Build & Publish ---
      # We use the existing Dockerfile, which is multi-stage.
      # To be ultra-efficient, we could build a minimal scratch image from the linux/amd64 binary we just built,
      # but using the Dockerfile ensures the image is exactly as defined in the repo source.
      # Since we use cross-compilation above, the compute saved is significant regardless.

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          # Push both 'latest' and the release tag (e.g. v1.0.0)
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/wolite:latest
            ${{ secrets.DOCKER_USERNAME }}/wolite:${{ github.event.release.tag_name }}
          # Also build for arm64 if possible (QEMU handles this)
          platforms: linux/amd64,linux/arm64

      # --- 6. Save and Upload Docker Image (Tarball) ---
      # This step creates a standalone tarball of the Docker image for manual loading.
      # We pull the image we just pushed to avoid rebuilding.

      - name: Save Docker Image
        run: |
          TAG_NAME="${{ steps.tag.outputs.TAG_NAME }}"

          # Pull the image we just pushed and save it
          docker pull ${{ secrets.DOCKER_USERNAME }}/wolite:${TAG_NAME}
          docker save ${{ secrets.DOCKER_USERNAME }}/wolite:${TAG_NAME} | gzip > "artifacts/wolite-${TAG_NAME}-docker.tar.gz"

      - name: Upload Docker Image to Release
        uses: softprops/action-gh-release@v2
        with:
          files: artifacts/wolite-*-docker.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
